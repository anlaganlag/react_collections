{"ast":null,"code":"import _objectSpread from \"/home/gal/Desktop/projects/react_learn_daily/React-Hooks-VideoPlayer-Finished/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread\";\nimport _slicedToArray from \"/home/gal/Desktop/projects/react_learn_daily/React-Hooks-VideoPlayer-Finished/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\n\nvar _this = this,\n    _jsxFileName = \"/home/gal/Desktop/projects/react_learn_daily/React-Hooks-VideoPlayer-Finished/src/components/containers/BestPlayer.js\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nimport React, { useState, useEffect } from \"react\";\nimport { ThemeProvider } from \"styled-components\";\nimport Video from \"../Video\";\nimport Playlist from \"../containers/Playlist\";\nimport StyledBestPlayer from \"../styles/StyledBestPlayer\";\n\nvar BestPlayer = function BestPlayer(props) {\n  var theme = {\n    bgcolor: \"#353535\",\n    bgcolorItem: \"#414141\",\n    bgcolorItemActive: \"#405c63\",\n    bgcolorPlayed: \"#526d4e\",\n    border: \"none\",\n    borderPlayed: \"none\",\n    color: \"#fff\"\n  };\n  var themeLight = {\n    bgcolor: \"#fff\",\n    bgcolorItem: \"#fff\",\n    bgcolorItemActive: \"#80a7b1\",\n    bgcolorPlayed: \"#7d9979\",\n    border: \"1px solid #353535\",\n    borderPlayed: \"none\",\n    color: \"#353535\"\n  };\n  var videos = JSON.parse(document.querySelector('[name=\"videos\"]').value);\n  var persistedState = JSON.parse(localStorage.getItem(\"\".concat(videos.playlistId)));\n\n  var _useState = useState({\n    videos: persistedState ? persistedState.videos : videos.playlist,\n    activeVideo: persistedState ? persistedState.activeVideo : videos.playlist[0],\n    nightMode: persistedState ? persistedState.nightMode : false,\n    playlistId: persistedState ? persistedState.playlistId : videos.playlistId,\n    autoplay: false\n  }),\n      _useState2 = _slicedToArray(_useState, 2),\n      state = _useState2[0],\n      setState = _useState2[1]; // This will only fire when the state updates\n\n\n  useEffect(function () {\n    localStorage.setItem(\"\".concat(state.playlistId), JSON.stringify(_objectSpread({}, state)));\n  }, [state]);\n  useEffect(function () {\n    if (props.match.params.activeVideo !== undefined) {\n      var newActiveVideo = findVideoIndex(props.match.params.activeVideo);\n      setState(_objectSpread({}, state, {\n        activeVideo: state.videos[newActiveVideo],\n        autoplay: props.location.autoplay\n      }));\n    } else {\n      // Navigate to the active video URL when going to root \"/\"\n      props.history.push({\n        pathname: \"/\".concat(state.activeVideo.id),\n        autoplay: false\n      });\n    }\n  }, [props.match.params.activeVideo] // Don't forget this. Will go into infinity loop otherwise\n  );\n\n  var nightModeCallback = function nightModeCallback() {\n    setState(_objectSpread({}, state, {\n      nightMode: !state.nightMode\n    }));\n  };\n\n  var endCallback = function endCallback() {\n    // First grab the index for the current video\n    var currentVideoIndex = findVideoIndex(props.match.params.activeVideo); // Then check for next video in the list. If there's no more videos go to beginning\n\n    var nextVideo = currentVideoIndex === state.videos.length - 1 ? 0 : currentVideoIndex + 1; // Then goto next video by pushing a new URL to the Router. Also pass the autoplay to determine\n    // if the video should not autoplay since it't the next in the list\n\n    props.history.push({\n      pathname: \"/\".concat(state.videos[nextVideo].id),\n      autoplay: false\n    });\n  };\n\n  var progressCallback = function progressCallback(e) {\n    // Set the status to \"played\" after 10 seconds\n    if (e.playedSeconds > 10 && e.playedSeconds < 11) {\n      setState(_objectSpread({}, state, {\n        videos: state.videos.map(function (element) {\n          return element.id === state.activeVideo.id ? _objectSpread({}, element, {\n            played: true\n          }) : element;\n        })\n      }));\n    }\n  };\n\n  var findVideoIndex = function findVideoIndex(videoId) {\n    var _iterator = _createForOfIteratorHelper(state.videos),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var video = _step.value;\n        if (video.id === videoId) return state.videos.indexOf(video);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  };\n\n  return /*#__PURE__*/React.createElement(ThemeProvider, {\n    theme: state.nightMode ? theme : themeLight,\n    __self: _this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 106,\n      columnNumber: 5\n    }\n  }, state.videos !== null ? /*#__PURE__*/React.createElement(StyledBestPlayer, {\n    __self: _this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 108,\n      columnNumber: 9\n    }\n  }, /*#__PURE__*/React.createElement(Video, {\n    active: state.activeVideo,\n    autoplay: state.autoplay,\n    endCallback: endCallback,\n    progressCallback: progressCallback,\n    __self: _this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 109,\n      columnNumber: 11\n    }\n  }), /*#__PURE__*/React.createElement(Playlist, {\n    videos: state.videos,\n    active: state.activeVideo,\n    nightModeCallback: nightModeCallback,\n    nightMode: state.nightMode,\n    __self: _this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 115,\n      columnNumber: 11\n    }\n  })) : null);\n};\n\nexport default BestPlayer;","map":{"version":3,"sources":["/home/gal/Desktop/projects/react_learn_daily/React-Hooks-VideoPlayer-Finished/src/components/containers/BestPlayer.js"],"names":["React","useState","useEffect","ThemeProvider","Video","Playlist","StyledBestPlayer","BestPlayer","props","theme","bgcolor","bgcolorItem","bgcolorItemActive","bgcolorPlayed","border","borderPlayed","color","themeLight","videos","JSON","parse","document","querySelector","value","persistedState","localStorage","getItem","playlistId","playlist","activeVideo","nightMode","autoplay","state","setState","setItem","stringify","match","params","undefined","newActiveVideo","findVideoIndex","location","history","push","pathname","id","nightModeCallback","endCallback","currentVideoIndex","nextVideo","length","progressCallback","e","playedSeconds","map","element","played","videoId","video","indexOf"],"mappings":"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","sourcesContent":["import React, { useState, useEffect } from \"react\";\nimport { ThemeProvider } from \"styled-components\";\nimport Video from \"../Video\";\nimport Playlist from \"../containers/Playlist\";\nimport StyledBestPlayer from \"../styles/StyledBestPlayer\";\n\nconst BestPlayer = props => {\n\n   const theme = {\n    bgcolor: \"#353535\",\n    bgcolorItem: \"#414141\",\n    bgcolorItemActive: \"#405c63\",\n    bgcolorPlayed: \"#526d4e\",\n    border: \"none\",\n    borderPlayed: \"none\",\n    color: \"#fff\"\n  };\n\n  const themeLight = {\n    bgcolor: \"#fff\",\n    bgcolorItem: \"#fff\",\n    bgcolorItemActive: \"#80a7b1\",\n    bgcolorPlayed: \"#7d9979\",\n    border: \"1px solid #353535\",\n    borderPlayed: \"none\",\n    color: \"#353535\"\n  };\n\n  const videos = JSON.parse(document.querySelector('[name=\"videos\"]').value);\n  const persistedState = JSON.parse(\n    localStorage.getItem(`${videos.playlistId}`)\n  );\n\n  const [state, setState] = useState({\n    videos: persistedState ? persistedState.videos : videos.playlist,\n    activeVideo: persistedState ? persistedState.activeVideo : videos.playlist[0],\n    nightMode: persistedState ? persistedState.nightMode : false,\n    playlistId: persistedState ? persistedState.playlistId : videos.playlistId,\n    autoplay: false,\n  });\n\n  // This will only fire when the state updates\n  useEffect(\n    () => {\n      localStorage.setItem(`${state.playlistId}`, JSON.stringify({ ...state }));\n    },\n    [state]\n  );\n\n  useEffect(\n    () => {\n      if (props.match.params.activeVideo !== undefined) {\n        const newActiveVideo = findVideoIndex(props.match.params.activeVideo);\n        setState({\n          ...state,\n          activeVideo: state.videos[newActiveVideo],\n          autoplay: props.location.autoplay,\n        });\n      } else {\n        // Navigate to the active video URL when going to root \"/\"\n        props.history.push({ pathname: `/${state.activeVideo.id}`, autoplay: false });\n      }\n    },\n    [props.match.params.activeVideo] // Don't forget this. Will go into infinity loop otherwise\n  );\n\n  const nightModeCallback = () => {\n    setState({ ...state, nightMode: !state.nightMode });\n  };\n\n  const endCallback = () => {\n    // First grab the index for the current video\n    const currentVideoIndex = findVideoIndex(props.match.params.activeVideo);\n    // Then check for next video in the list. If there's no more videos go to beginning\n    const nextVideo =\n      currentVideoIndex === state.videos.length - 1 ? 0 : currentVideoIndex + 1;\n    // Then goto next video by pushing a new URL to the Router. Also pass the autoplay to determine\n    // if the video should not autoplay since it't the next in the list\n    props.history.push({\n      pathname: `/${state.videos[nextVideo].id}`,\n      autoplay: false\n    });\n  };\n\n  const progressCallback = e => {\n    // Set the status to \"played\" after 10 seconds\n    if (e.playedSeconds > 10 && e.playedSeconds < 11) {\n      setState({\n        ...state,\n        videos: state.videos.map(element => {\n          return element.id === state.activeVideo.id\n            ? { ...element, played: true }\n            : element;\n        })\n      });\n    }\n  };\n\n  const findVideoIndex = videoId => {\n    for (let video of state.videos) {\n      if (video.id === videoId) return state.videos.indexOf(video);\n    }\n  };\n\n  return (\n    <ThemeProvider theme={state.nightMode ? theme : themeLight}>\n      {state.videos !== null ? (\n        <StyledBestPlayer>\n          <Video\n            active={state.activeVideo}\n            autoplay={state.autoplay}\n            endCallback={endCallback}\n            progressCallback={progressCallback}\n          />\n          <Playlist\n            videos={state.videos}\n            active={state.activeVideo}\n            nightModeCallback={nightModeCallback}\n            nightMode={state.nightMode}\n          />\n        </StyledBestPlayer>\n      ) : null}\n    </ThemeProvider>\n  );\n};\n\nexport default BestPlayer;"]},"metadata":{},"sourceType":"module"}